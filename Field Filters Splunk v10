asic Splunk 10 field-extraction example (using host, sourcetype, source, POR, _time, and event_count from your tstats search)

Suppose you want to extract a simple field "env" from the source name when source contains an environment token like "/prod/" or "/dev/". Use rex to extract after field filters and parsing (post‑extraction), e.g.:

index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count by env sourcetype
| where env="prod"

Explanation:

Field filters (index, sourcetype, host) are placed first so Splunk 10 applies them before extraction.
rex extracts the new field env from the parsed source value.
stats aggregates by the newly extracted field; where filters on env (a computed/extracted field) run after extraction/aggregation.
If you want an extraction on _raw for later use with tstats, perform the rex before tstats and ensure the extracted field is indexed or you use search-based aggregation instead of tstats.

using same analogy as above,show us the situation in splunk 9

DA
Pre‑Splunk 10 (Splunk 9) — same example, behavior and SPL

Situation (Splunk 9): field filters could be evaluated later in the pipeline, so authors often relied on filtering/searching against fields created by later commands without needing where/eventstats first.

Example SPL (would work in Splunk 9):
index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count BY env sourcetype
| search env="prod"
| where event_count>10

Why this worked in Splunk 9:

The "| search env='prod'" used after stats could be evaluated after rex/stats created env and event_count, so it filtered correctly.
Authors commonly mixed search-based filters after transforms because the old ordering allowed it.
Key difference vs Splunk 10:

In Splunk 10 a "| search env='prod'" placed after stats may be treated as an early field filter (executed before rex/stats create env), so it may fail; the correct pattern in v10 is to use "| where env='prod'" (or compute with eventstats) after the transform.
Regenerate
Copy
Good response
Bad response


###########################################################################################################################

Here are 5 concise SPL examples you can run to demonstrate Splunk 10’s field‑filters‑first behavior, with a one‑line note about what each shows.

Broken vs fixed (aggregate then filter)
Broken (will fail in v10 if using search on computed field): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Fixed: index=main sourcetype=access_combined | stats count BY clientip | where count>5 Shows that "search" cannot filter on fields created by stats in v10; use where.
Preserve per-event context with eventstats
index=main sourcetype=access_combined
| eval is_error=if(status>=500,1,0)
| eventstats sum(is_error) AS error_count BY clientip
| where error_count>10
| table _time clientip error_count status uri
Shows attaching aggregates to each event so you can filter by them after Splunk’s early field filters.

Search-time extraction vs early filter (use rex after initial filters)
index=main host=webserver* earliest=-24h
| rex field=_raw "user=(?\w+)"
| stats count BY user
| where count>3
Demonstrates that custom search-time extractions (rex) produce fields usable by where (post-extraction) — but ensure you don’t try to use "search user=..." if user is only created by rex.

tstats vs metadata speed & behavior
| tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host
| sort -count
Shows using tstats for indexed fields (fast, uses indexes) and that tstats returns source/host/sourcetype info available at index level, unaffected by search-time ordering.

Field-filter ordering with subsearch (compute then filter via subsearch)
index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ]
| stats count BY clientip
Demonstrates using a subsearch (which runs first) to compute a list, then the outer search filters by that list — a pattern to work around early field-filter limitations when necessary.

Run these in your environment with appropriate time ranges; use Search Job Inspector to show when fields are created and when filters are applied for each example.

modify each examples to show the state of things before splunk 10 and after splunk 10

DA
Aggregate then filter (count by clientip)
Pre‑Splunk 10 (worked): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Splunk 10 (fix): index=main sourcetype=access_combined | stats count BY clientip | where count>5
Per‑event aggregate with eventstats
Pre‑Splunk 10 (authors sometimes used search after stats): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | stats sum(is_error) AS error_count BY clientip | search error_count>10
Splunk 10 (correct; preserve per‑event context alternative): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | eventstats sum(is_error) AS error_count BY clientip | where error_count>10 | table _time clientip error_count status uri
Search‑time extraction (rex) usage
Pre‑Splunk 10 (could filter on rex-created field using search): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | search user="alice"
Splunk 10 (use where after rex): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | where user="alice"
tstats / metadata (indexed aggregation — unaffected by field-filter ordering)
Pre‑Splunk 10: | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Splunk 10 (same; tstats unaffected and recommended for performance): | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Subsearch workaround
Pre‑Splunk 10 (subsearch used less often for this reason, but worked either way): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | search count>5 | fields clientip ] | stats count BY clientip
Splunk 10 (explicit: compute list in subsearch, then filter outer search): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ] | stats count BY clientip
Notes: In all “Pre‑Splunk 10” examples authors often used "| search " after transforms; in Splunk 10 replace such uses with "| where" or compute aggregates with eventstats/streamstats or use subsearch/tstats patterns.
