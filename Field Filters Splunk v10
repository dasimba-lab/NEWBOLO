asic Splunk 10 field-extraction example (using host, sourcetype, source, POR, _time, and event_count from your tstats search)

Suppose you want to extract a simple field "env" from the source name when source contains an environment token like "/prod/" or "/dev/". Use rex to extract after field filters and parsing (post‑extraction), e.g.:

index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count by env sourcetype
| where env="prod"

Explanation:

Field filters (index, sourcetype, host) are placed first so Splunk 10 applies them before extraction.
rex extracts the new field env from the parsed source value.
stats aggregates by the newly extracted field; where filters on env (a computed/extracted field) run after extraction/aggregation.
If you want an extraction on _raw for later use with tstats, perform the rex before tstats and ensure the extracted field is indexed or you use search-based aggregation instead of tstats.

using same analogy as above,show us the situation in splunk 9

DA
Pre‑Splunk 10 (Splunk 9) — same example, behavior and SPL

Situation (Splunk 9): field filters could be evaluated later in the pipeline, so authors often relied on filtering/searching against fields created by later commands without needing where/eventstats first.

Example SPL (would work in Splunk 9):
index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count BY env sourcetype
| search env="prod"
| where event_count>10

Why this worked in Splunk 9:

The "| search env='prod'" used after stats could be evaluated after rex/stats created env and event_count, so it filtered correctly.
Authors commonly mixed search-based filters after transforms because the old ordering allowed it.
Key difference vs Splunk 10:

In Splunk 10 a "| search env='prod'" placed after stats may be treated as an early field filter (executed before rex/stats create env), so it may fail; the correct pattern in v10 is to use "| where env='prod'" (or compute with eventstats) after the transform.
Regenerate
Copy
Good response
Bad response


###########################################################################################################################

Here are 5 concise SPL examples you can run to demonstrate Splunk 10’s field‑filters‑first behavior, with a one‑line note about what each shows.

Broken vs fixed (aggregate then filter)
Broken (will fail in v10 if using search on computed field): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Fixed: index=main sourcetype=access_combined | stats count BY clientip | where count>5 Shows that "search" cannot filter on fields created by stats in v10; use where.
Preserve per-event context with eventstats
index=main sourcetype=access_combined
| eval is_error=if(status>=500,1,0)
| eventstats sum(is_error) AS error_count BY clientip
| where error_count>10
| table _time clientip error_count status uri
Shows attaching aggregates to each event so you can filter by them after Splunk’s early field filters.

Search-time extraction vs early filter (use rex after initial filters)
index=main host=webserver* earliest=-24h
| rex field=_raw "user=(?\w+)"
| stats count BY user
| where count>3
Demonstrates that custom search-time extractions (rex) produce fields usable by where (post-extraction) — but ensure you don’t try to use "search user=..." if user is only created by rex.

tstats vs metadata speed & behavior
| tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host
| sort -count
Shows using tstats for indexed fields (fast, uses indexes) and that tstats returns source/host/sourcetype info available at index level, unaffected by search-time ordering.

Field-filter ordering with subsearch (compute then filter via subsearch)
index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ]
| stats count BY clientip
Demonstrates using a subsearch (which runs first) to compute a list, then the outer search filters by that list — a pattern to work around early field-filter limitations when necessary.

Run these in your environment with appropriate time ranges; use Search Job Inspector to show when fields are created and when filters are applied for each example.

modify each examples to show the state of things before splunk 10 and after splunk 10

DA
Aggregate then filter (count by clientip)
Pre‑Splunk 10 (worked): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Splunk 10 (fix): index=main sourcetype=access_combined | stats count BY clientip | where count>5
Per‑event aggregate with eventstats
Pre‑Splunk 10 (authors sometimes used search after stats): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | stats sum(is_error) AS error_count BY clientip | search error_count>10
Splunk 10 (correct; preserve per‑event context alternative): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | eventstats sum(is_error) AS error_count BY clientip | where error_count>10 | table _time clientip error_count status uri
Search‑time extraction (rex) usage
Pre‑Splunk 10 (could filter on rex-created field using search): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | search user="alice"
Splunk 10 (use where after rex): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | where user="alice"
tstats / metadata (indexed aggregation — unaffected by field-filter ordering)
Pre‑Splunk 10: | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Splunk 10 (same; tstats unaffected and recommended for performance): | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Subsearch workaround
Pre‑Splunk 10 (subsearch used less often for this reason, but worked either way): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | search count>5 | fields clientip ] | stats count BY clientip
Splunk 10 (explicit: compute list in subsearch, then filter outer search): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ] | stats count BY clientip
Notes: In all “Pre‑Splunk 10” examples authors often used "| search " after transforms; in Splunk 10 replace such uses with "| where" or compute aggregates with eventstats/streamstats or use subsearch/tstats patterns.



###################################################################################################################################################

Below are the five demo examples revised to use your environment’s fields/structure (tstats with latest time, source, sourcetype, POR). Each pair shows pre‑Splunk‑10 (problematic use of "search" on computed fields) and Splunk‑10 correct patterns (use where/eventstats/subsearch/tstats). Adjust time ranges as needed.

Aggregate then filter (count by source)
Pre‑Splunk 10 (would rely on search seeing computed field): | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:audit:logs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | eval duration = now() - latest(_time) | stats count BY source | search count>5
Splunk 10 (correct): | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:audit:logs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | stats count BY source | where count>5
Per‑event/per‑source aggregate with eventstats (error-like flag)
Pre‑Splunk 10 (problematic): | tstats latest(_time) AS time values(POR) AS POR WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:cloudtrail OR sourcetype=aws:audit:logs) BY source,sourcetype | eval duration = now() - time | stats sum(eval(duration>3600)) AS late_count BY source | search late_count>3
Splunk 10 (correct — use eventstats to attach counts then filter): | tstats latest(_time) AS time values(POR) AS POR WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:cloudtrail OR sourcetype=aws:audit:logs) BY source,sourcetype | eval is_late = if(isnull(time) OR now()-time>3600,1,0) | eventstats sum(is_late) AS late_count BY source | where late_count>3 | table source, sourcetype, POR, late_count
Search-time extraction (rex) then filter by extracted field
Pre‑Splunk 10 (could use search on rex field after stats): index=cloud-aws host="splunk-httpinput.health.mil" sourcetype=aws:elb:accesslogs | rex field=_raw "client=(?\w+)" | stats count BY client_id | search client_id="ABC123"
Splunk 10 (correct — use where after stats): index=cloud-aws host="splunk-httpinput.health.mil" sourcetype=aws:elb:accesslogs | rex field=_raw "client=(?\w+)" | stats count BY client_id | where client_id="ABC123" | table client_id, count
tstats (indexed) aggregation — unaffected by ordering (recommended)
Pre‑Splunk 10 and Splunk 10 (same; fast): | tstats latest(_time) AS time count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | eval duration = now() - time | eval status = case(isnull(time),"Missing", duration>3600,"Missing", true(),"OK") | eval LatestEvent = strftime(time, "%Y-%m-%d %H:%M:%S") | eval duration = tostring(duration,"duration") | table count, source, sourcetype, status, duration, LatestEvent
Subsearch workaround (compute list then filter outer search)
Pre‑Splunk 10 (subsearch with search): | tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype | stats count BY source | search count>5
Splunk 10 (compute list in subsearch then filter outer tstats): | tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype | where time>relative_time(now(), "-7d") | fields source sourcetype [ -- or use subsearch pattern: compute high-volume sources first -- ] index=cloud-aws [ search index=cloud-aws host="splunk-httpinput.health.mil" | tstats count WHERE index=cloud-aws BY source | where count>5 | fields source ] sourcetype=* | tstats count latest(_time) AS time WHERE index=cloud-aws BY source,sourcetype | table count, source, sourcetype, time
Notes:

I aligned fields to your environment: use tstats latest(_time) AS time (or recentTime), values(POR) as POR where needed.
Replace time with recentTime or LatestEvent naming consistently if you prefer.
Use where/eventstats instead of search when filtering on computed or tstats-created fields under Splunk 10.
Run Job Inspector on each to show when fields are created and when filters apply.


#########################################################################################################################################################

Aggregate then filter (by source)
Broken (may fail in v10):
| tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| search count>5
Correct (v10):
| tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| where count>5
Latest-event age filter (status)
Broken (may fail in v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval duration = now()-time
| eval status = if(duration>3600,"Missing","OK")
| search status="Missing"
Correct (v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval duration = now()-time
| eval status = if(duration>3600,"Missing","OK")
| where status="Missing"
Filter on extracted field (client_id from ELB logs)
Broken (may fail in v10):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex field=_raw "client=(?\w+)"
| stats count BY client_id
| search client_id="ABC123"
Correct (v10):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex field=_raw "client=(?\w+)"
| stats count BY client_id
| where client_id="ABC123"
Per-source lateness count (use eventstats)
Broken (may fail in v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval is_late = if(isnull(time) OR now()-time>3600,1,0)
| stats sum(is_late) AS late_count BY source
| search late_count>3
Correct (v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval is_late = if(isnull(time) OR now()-time>3600,1,0)
| eventstats sum(is_late) AS late_count BY source
| where late_count>3
Subsearch to precompute sources then outer tstats (workaround)
Broken (may fail in v10):
| tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| search count>5
Correct (v10):
index=cloud-aws [ | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source | where count>5 | fields source ] sourcetype=*
| tstats count latest(_time) AS time WHERE index=cloud-aws BY source,sourcetype
| table count, source, sourcetype, time
Regenerate
Copy
Good response
Bad response

Type a message...


