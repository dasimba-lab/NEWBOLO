asic Splunk 10 field-extraction example (using host, sourcetype, source, POR, _time, and event_count from your tstats search)

Suppose you want to extract a simple field "env" from the source name when source contains an environment token like "/prod/" or "/dev/". Use rex to extract after field filters and parsing (post‑extraction), e.g.:

index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count by env sourcetype
| where env="prod"

Explanation:

Field filters (index, sourcetype, host) are placed first so Splunk 10 applies them before extraction.
rex extracts the new field env from the parsed source value.
stats aggregates by the newly extracted field; where filters on env (a computed/extracted field) run after extraction/aggregation.
If you want an extraction on _raw for later use with tstats, perform the rex before tstats and ensure the extracted field is indexed or you use search-based aggregation instead of tstats.

using same analogy as above,show us the situation in splunk 9

DA
Pre‑Splunk 10 (Splunk 9) — same example, behavior and SPL

Situation (Splunk 9): field filters could be evaluated later in the pipeline, so authors often relied on filtering/searching against fields created by later commands without needing where/eventstats first.

Example SPL (would work in Splunk 9):
index=cloud-aws sourcetype=aws:cloudtrail host="splunk-httpinput.health.mil"
| rex field=source "(?/(prod|dev|staging)/)"
| stats count AS event_count BY env sourcetype
| search env="prod"
| where event_count>10

Why this worked in Splunk 9:

The "| search env='prod'" used after stats could be evaluated after rex/stats created env and event_count, so it filtered correctly.
Authors commonly mixed search-based filters after transforms because the old ordering allowed it.
Key difference vs Splunk 10:

In Splunk 10 a "| search env='prod'" placed after stats may be treated as an early field filter (executed before rex/stats create env), so it may fail; the correct pattern in v10 is to use "| where env='prod'" (or compute with eventstats) after the transform.
Regenerate
Copy
Good response
Bad response


###########################################################################################################################

Here are 5 concise SPL examples you can run to demonstrate Splunk 10’s field‑filters‑first behavior, with a one‑line note about what each shows.

Broken vs fixed (aggregate then filter)
Broken (will fail in v10 if using search on computed field): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Fixed: index=main sourcetype=access_combined | stats count BY clientip | where count>5 Shows that "search" cannot filter on fields created by stats in v10; use where.
Preserve per-event context with eventstats
index=main sourcetype=access_combined
| eval is_error=if(status>=500,1,0)
| eventstats sum(is_error) AS error_count BY clientip
| where error_count>10
| table _time clientip error_count status uri
Shows attaching aggregates to each event so you can filter by them after Splunk’s early field filters.

Search-time extraction vs early filter (use rex after initial filters)
index=main host=webserver* earliest=-24h
| rex field=_raw "user=(?\w+)"
| stats count BY user
| where count>3
Demonstrates that custom search-time extractions (rex) produce fields usable by where (post-extraction) — but ensure you don’t try to use "search user=..." if user is only created by rex.

tstats vs metadata speed & behavior
| tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host
| sort -count
Shows using tstats for indexed fields (fast, uses indexes) and that tstats returns source/host/sourcetype info available at index level, unaffected by search-time ordering.

Field-filter ordering with subsearch (compute then filter via subsearch)
index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ]
| stats count BY clientip
Demonstrates using a subsearch (which runs first) to compute a list, then the outer search filters by that list — a pattern to work around early field-filter limitations when necessary.

Run these in your environment with appropriate time ranges; use Search Job Inspector to show when fields are created and when filters are applied for each example.

modify each examples to show the state of things before splunk 10 and after splunk 10

DA
Aggregate then filter (count by clientip)
Pre‑Splunk 10 (worked): index=main sourcetype=access_combined | stats count BY clientip | search count>5
Splunk 10 (fix): index=main sourcetype=access_combined | stats count BY clientip | where count>5
Per‑event aggregate with eventstats
Pre‑Splunk 10 (authors sometimes used search after stats): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | stats sum(is_error) AS error_count BY clientip | search error_count>10
Splunk 10 (correct; preserve per‑event context alternative): index=main sourcetype=access_combined | eval is_error=if(status>=500,1,0) | eventstats sum(is_error) AS error_count BY clientip | where error_count>10 | table _time clientip error_count status uri
Search‑time extraction (rex) usage
Pre‑Splunk 10 (could filter on rex-created field using search): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | search user="alice"
Splunk 10 (use where after rex): index=main host=webserver* earliest=-24h | rex field=_raw "user=(?\w+)" | stats count BY user | where user="alice"
tstats / metadata (indexed aggregation — unaffected by field-filter ordering)
Pre‑Splunk 10: | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Splunk 10 (same; tstats unaffected and recommended for performance): | tstats count WHERE index=_internal AND sourcetype=splunkd_bytray BY host | sort -count
Subsearch workaround
Pre‑Splunk 10 (subsearch used less often for this reason, but worked either way): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | search count>5 | fields clientip ] | stats count BY clientip
Splunk 10 (explicit: compute list in subsearch, then filter outer search): index=main sourcetype=access_combined [ search index=main sourcetype=access_combined | stats count BY clientip | where count>5 | fields clientip ] | stats count BY clientip
Notes: In all “Pre‑Splunk 10” examples authors often used "| search " after transforms; in Splunk 10 replace such uses with "| where" or compute aggregates with eventstats/streamstats or use subsearch/tstats patterns.



###################################################################################################################################################

Below are the five demo examples revised to use your environment’s fields/structure (tstats with latest time, source, sourcetype, POR). Each pair shows pre‑Splunk‑10 (problematic use of "search" on computed fields) and Splunk‑10 correct patterns (use where/eventstats/subsearch/tstats). Adjust time ranges as needed.

Aggregate then filter (count by source)
Pre‑Splunk 10 (would rely on search seeing computed field): | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:audit:logs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | eval duration = now() - latest(_time) | stats count BY source | search count>5
Splunk 10 (correct): | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:audit:logs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | stats count BY source | where count>5
Per‑event/per‑source aggregate with eventstats (error-like flag)
Pre‑Splunk 10 (problematic): | tstats latest(_time) AS time values(POR) AS POR WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:cloudtrail OR sourcetype=aws:audit:logs) BY source,sourcetype | eval duration = now() - time | stats sum(eval(duration>3600)) AS late_count BY source | search late_count>3
Splunk 10 (correct — use eventstats to attach counts then filter): | tstats latest(_time) AS time values(POR) AS POR WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:cloudtrail OR sourcetype=aws:audit:logs) BY source,sourcetype | eval is_late = if(isnull(time) OR now()-time>3600,1,0) | eventstats sum(is_late) AS late_count BY source | where late_count>3 | table source, sourcetype, POR, late_count
Search-time extraction (rex) then filter by extracted field
Pre‑Splunk 10 (could use search on rex field after stats): index=cloud-aws host="splunk-httpinput.health.mil" sourcetype=aws:elb:accesslogs | rex field=_raw "client=(?\w+)" | stats count BY client_id | search client_id="ABC123"
Splunk 10 (correct — use where after stats): index=cloud-aws host="splunk-httpinput.health.mil" sourcetype=aws:elb:accesslogs | rex field=_raw "client=(?\w+)" | stats count BY client_id | where client_id="ABC123" | table client_id, count
tstats (indexed) aggregation — unaffected by ordering (recommended)
Pre‑Splunk 10 and Splunk 10 (same; fast): | tstats latest(_time) AS time count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" AND (sourcetype=aws:elb:accesslogs OR sourcetype=aws:cloudtrail OR sourcetype=aws:route53) BY source,sourcetype | eval duration = now() - time | eval status = case(isnull(time),"Missing", duration>3600,"Missing", true(),"OK") | eval LatestEvent = strftime(time, "%Y-%m-%d %H:%M:%S") | eval duration = tostring(duration,"duration") | table count, source, sourcetype, status, duration, LatestEvent
Subsearch workaround (compute list then filter outer search)
Pre‑Splunk 10 (subsearch with search): | tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype | stats count BY source | search count>5
Splunk 10 (compute list in subsearch then filter outer tstats): | tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype | where time>relative_time(now(), "-7d") | fields source sourcetype [ -- or use subsearch pattern: compute high-volume sources first -- ] index=cloud-aws [ search index=cloud-aws host="splunk-httpinput.health.mil" | tstats count WHERE index=cloud-aws BY source | where count>5 | fields source ] sourcetype=* | tstats count latest(_time) AS time WHERE index=cloud-aws BY source,sourcetype | table count, source, sourcetype, time
Notes:

I aligned fields to your environment: use tstats latest(_time) AS time (or recentTime), values(POR) as POR where needed.
Replace time with recentTime or LatestEvent naming consistently if you prefer.
Use where/eventstats instead of search when filtering on computed or tstats-created fields under Splunk 10.
Run Job Inspector on each to show when fields are created and when filters apply.


#########################################################################################################################################################

Aggregate then filter (by source)
Broken (may fail in v10):
| tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| search count>5
Correct (v10):
| tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| where count>5
Latest-event age filter (status)
Broken (may fail in v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval duration = now()-time
| eval status = if(duration>3600,"Missing","OK")
| search status="Missing"
Correct (v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval duration = now()-time
| eval status = if(duration>3600,"Missing","OK")
| where status="Missing"
Filter on extracted field (client_id from ELB logs)
Broken (may fail in v10):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex field=_raw "client=(?\w+)"
| stats count BY client_id
| search client_id="ABC123"
Correct (v10):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex field=_raw "client=(?\w+)"
| stats count BY client_id
| where client_id="ABC123"
Per-source lateness count (use eventstats)
Broken (may fail in v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval is_late = if(isnull(time) OR now()-time>3600,1,0)
| stats sum(is_late) AS late_count BY source
| search late_count>3
Correct (v10):
| tstats latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| eval is_late = if(isnull(time) OR now()-time>3600,1,0)
| eventstats sum(is_late) AS late_count BY source
| where late_count>3
Subsearch to precompute sources then outer tstats (workaround)
Broken (may fail in v10):
| tstats count latest(_time) AS time WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source,sourcetype
| stats count BY source
| search count>5
Correct (v10):
index=cloud-aws [ | tstats count WHERE index=cloud-aws AND host="splunk-httpinput.health.mil" BY source | where count>5 | fields source ] sourcetype=*
| tstats count latest(_time) AS time WHERE index=cloud-aws BY source,sourcetype
| table count, source, sourcetype, time
Regenerate
Copy
Good response
Bad response

Type a message...
#############################################################################################################################################################




DA
Search (example using your environment — starts with index=, source=, sourcetype=):
index=cloud-aws source="/var/log/aws/elb/*" sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil" earliest=-24h
| rex field=_raw "client=(?\w+)"
| eval event_ts = coalesce(_time, strptime(_raw, "%Y-%m-%dT%H:%M:%S"))
| stats count latest(_time) AS recentTime values(client_id) AS clients BY source,sourcetype, host
| eval age = now() - recentTime
| eval status = if(isnull(recentTime) OR age>900, "Missing", "OK")
| eval duration = if(status=="Missing", tostring(age,"duration"), "0s")
| table count, source, sourcetype, host, status, duration, recentTime, clients

How Splunk 10 differs vs prior versions (mapped to index/search time processes)

Index time (unchanged behavior)

Default field extraction: host, source, sourcetype, and timestamp are still set at ingest (index time) — your index=, source=, sourcetype= filters rely on these.
Host assignment / sourcetype customization / index-time extractions / timestamping / linebreaking / segmentation continue to run before data is written to disk — nothing changed here in v10.
Search time (major change in Splunk 10)

Field filters first: In Splunk 10, any search-time field filters (the initial index=, source=, sourcetype=, host= and any leading "search field=value" clauses) are applied before parsing/timestamping and before search-time field extraction (rex, automatic extractions). In the example above, the index/source/sourcetype host filters are correctly placed first so Splunk 10 will apply them early and reduce event volume.
Effect on rex / search-time extraction: Because field filters run first, do not expect a leading "search" to be able to filter on fields created later by rex/stats/eval — those fields don’t exist yet when early filters are applied. In this search, rex runs after initial filtering and creates client_id for stats/aggregation — but you must not use "| search client_id=..." earlier in the pipeline; use "| where client_id=..." after rex/stats.
Event segmentation & event typing: These still occur at search time, but segmentation now happens after early filters; any filters that would remove events before segmentation will change the set of events segmented/typed.
Field aliasing / lookups / sourcetype renaming / tagging: All search-time enrichments happen after the early field filters; if a field needed for lookup is filtered out early, the enrichment will not run for those events. For example, if you filtered out events by a field that would have been aliased later, that alias never occurs.
Practical consequences:
Avoid using "search" to filter on computed or extracted fields (pre-v10 patterns like "| stats ... | search count>5" must be replaced with "| where count>5").
Use eventstats/streamstats to retain per-event aggregates when you need to filter on them.
Keep raw-field filters (index/source/sourcetype/host) explicit at the start to benefit from early volume reduction.
Validate DMA/CIM impacts: early filters may remove events needed for data model acceleration or CIM mappings; re-run accelerations if necessary.
Quick concrete before/after example using the query context

Pre‑Splunk 10 (worked):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex "client=(?\w+)"
| stats count BY client_id
| search count>5

Splunk 10 (correct):
index=cloud-aws sourcetype=aws:elb:accesslogs host="splunk-httpinput.health.mil"
| rex "client=(?\w+)"
| stats count BY client_id
| where count>5

Summary

Index-time processes remain responsible for initial field extraction, sourcetype assignment, timestamping, and linebreaking.
Splunk 10 moves search-time field filters to the very start of the search pipeline — this improves performance but requires rewriting any searches that filtered on fields created later in the pipeline (use where/eventstats/streamstats, or compute via subsearches/tstats).


